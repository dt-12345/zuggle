Made with [exlaunch](https://github.com/shadowninja108/exlaunch)

This mod allows you to "zuggle" any equipped weapon, bow, and/or shield when whistling.

Zuggling is a well-known glitch in *Tears of the Kingdom* and this mod was made primarily to gain a better understanding of its inner workings. In the simplest terms, a piece of equipment is "zuggled" when the corresponding equipment ActorLink is removed or replaced in EquipmentUserComponent while the calculation dependency between the equipment and the user remains. This state can be achieved through a variety of different in-game methods but this mod aims at achieving it programmatically on command.

In the glitch hunting community, zuggling is recognized as taking two forms: "dynamic" and "static" (or normal) zuggles. While this terminology is not exactly accurate, these two forms do clearly exist. The difference arises from a single boolean value being set to either true or false in the zuggled equipment's DynamicEquipmentComponent. This value which I will just refer as `mPendingDrop`, is set when a piece of equipment is queued up to be dropped. While true, this causes the equipment to ignore any state change requests from its equipment user with the exception of dropping. This results in a standard zuggle. A dynamic zuggle occurs when this value is false, meaning the equipment will ignore any drop requests but respect any other state change requests. The zuggle triggered by this mod is a standard zuggle with the equipment being stuck in the equipped and drawn state.

As for in-game methods of achieving a zuggle, I'll briefly go over map zuggling which exists on versions 1.0.0, 1.1.0, and 1.1.1. The key point that allows map zuggling to achieve the zuggle state is what happens between the equipping of the second piece of equipment in the quick menu and the map screen opening. To understand why, we first have to discuss the game's drop mechanics. When dropping a piece of equipment, the actor is not immediately "dropped" and unlinked from Link (as you can drop multiple items without unpausing). Instead, when dropping an item, it loads the dropped items up into a ring buffer in `game::pouchcontent::PouchMgr` and requests for the creation of the dropped items. Additionally, if that item was equipped in EquipmentUserComponent when dropped, it caches the link to the dropped item in EquipmentUserComponent. Note that this does not yet invalidate the equipment link. Then, when PouchMgr goes to process the dropped items buffer, if an item actor failed to be created, it requests the "You cannot take this out here" pop-up and readds the items to the inventory. Additionally, it can do one of two things other things depending on the item's equip status when dropped. If the item was not equipped or only equipped in the inventory (GameData) but not in EquipmentUserComponent (such as equipping a piece of equipment through the inventory menu without unpausing), it does nothing. However, if the item was equipped in both the inventory and in EquipmentUserComponent, then it checks whether or not there is a currently equipped item in the corresponding slot in the inventory (GameData). If there is, it requests that the cached dropped equipment be uncached. Otherwise, it requests for the cached dropped equipment to be equipped. In this equipping process, if the currently equipped weapon does not match the cached weapon, it unlinks and deletes the currently equipped weapon and sets it to the requested one. You know this happens if you here the unequipping sound (which is distinct from the normal swapping/equipping sound).

Now, let's walk through the example of map zuggling. Firstly, you use the map rune and open the quick menu before it opens the map. Then, you drop the currently equipped item from the quick menu and quickly reopen it and swap to a new item. Then, you close the quick menu and the map opens. This is the crucial step. Because the quick menu equips an item in both the inventory and EquipmentUserComponent upon closure, the newly equipped item is now equipped in both places. When equipping this piece of equipment, the cached dropped item is the same as the currently equipped item so the old link is not destroyed (this is intentional behavior). Instead, it overwrites the old link with a link to the newly equipped item. Then when you drop it from the inventory, it fulfills PouchMgr's additional condition when dropping fails. So, when PouchMgr processes the dropped items, the currently cached piece of equipment is the same as the currently equipped piece of equipment in EquipmentUserComponent. Additionally, there is no currently equipped item in the inventory (GameData) because you dropped it from the inventory. This means PouchMgr will send the equip request and because the cached item matches the equipped item, nothing is removed and the cached link is discarded. Now, when the second drop is process (a.k.a the first item dropped), the cache link is invalid so the equip function exits early and nothing happens. This results in there being two pieces of equipment retaining their calculation dependency with the equipment user while only one equipment ActorLink exists, in other words, a zuggle. If you instead think about the scenario where you don't drop the second item, the cached item will not match the currently equipped item so the item equipped second will be destroyed and its dependencies resolved. Or, if you consider the case where you equip and drop the items using the inventory menu instead of the map rune + quick menu, you will realize that the equipped item in EquipmentUserComponent is never updated so once again, the cached item does not match and the dependencies are resolved properly. 